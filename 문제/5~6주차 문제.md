# 5~6주차 문제

**학습 범위 : 배열(7장), 함수(8장), 포인터(10장), 구조체 및 동적 기억장소 할당(11장)**

## **1. 배열 교환 문제**

아래의 역할을 수행하는 main() 함수와 배열 교환 함수 ‘swap’을 구현하고, swap 이후의 배열을 출력하는 프로그램을 작성하세요. 

메인 함수 main()은 다음의 역할을 수행합니다 :

1. “두 배열의 크기를 입력하세요.”를 출력합니다.
2. 두 배열의 크기를 입력 받습니다. 만약 배열의 크기로 0이 입력된 경우, “배열의 크기는 0이 될 수 없습니다.”를 출력하고 크기를 다시 입력 받습니다. 0이 아닌 수들이 입력될 때까지 반복 합니다.
3. “배열 A를 입력하세요.”를 출력하고 배열 A를 입력 받습니다. 
4. “배열 B를 입력하세요.”를 출력하고 배열 B를 입력 받습니다.
5. 함수 swap()을 호출합니다.
6. swap 이후의 배열을 출력합니다.

<br>함수 swap은 다음의 역할을 수행합니다 :

→ 두 배열의 길이에 따라 아래와 같은 역할을 수행합니다.

[두 배열의 길이가 같은 경우]

즉시 두 배열을 서로 바꾸어 줍니다. 즉 배열 A에는 B의 원소가, 배열 B에는 배열 A의 원소가 들어가게 됩니다.

[두 배열의 길이가 다른 경우]

길이가 작은 배열의 크기를 **길이가 큰 배열의 크기와 동일하도록** 바꾸어 줍니다. 이후 원소를 앞에서부터 채워 넣되, 남는 길이 만큼 **숫자 0을 대입**합니다.

즉, 다음과 같은 식입니다.

배열 A : [1, 3, 2, 5, 6]

배열 B : [2, 9, 10]

배열 A의 길이 (5)가 배열 B의 길이(3)보다 큽니다. 따라서 배열 B의 길이를 5로 바꾸어 주고 원소를 앞에서부터 채워 넣되, 남은 길이 만큼 숫자 0을 대입합니다.

즉, 배열 B는 [2, 9, 10, 0, 0]가 됩니다.

이후 배열 A와 B를 서로 교환합니다.

[예제 시나리오 1]

![1.jpg](5~6%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%20c29615bd86e1416bb3d653378e21d8e9/1.jpg)

[예제 시나리오 2]

![2.jpg](5~6%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%20c29615bd86e1416bb3d653378e21d8e9/2.jpg)

[예제 시나리오 3]

![4.jpg](5~6%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%20c29615bd86e1416bb3d653378e21d8e9/4.jpg)

## 2. 구조체를 활용한 게임 프로그램 문제

구조체를 활용하여 다음과 같은 게임 프로그램을 코딩하세요.

1. Monster과 User이라는 구조체를 정의합니다. 두 구조체는 모두 이름(name; char형), 체력(health; int형), 공격력 (attack; int형) 이라는 변수를 포함하고 있습니다.
2. **구조체 배열**을 이용하여 M마리의 Monster, N명의 User을 생성합니다. M, N은 **1 이상의 자연수**로 자유롭게 구현합니다. 생성한 Monster, User의 정보를 입력 받습니다. 이름과 체력, 공격력은 자유롭게 입력하면 되고, 반드시 동적 배열으로 입력받을 필요는 없습니다.
3. 0번 인덱스의 Monster, User부터 서로 1대 1로 싸웁니다. **서로 동시에 피해를 주고 받는데**, 매 턴마다 자신의 체력 = (현재 자신의 체력 – 적의 공격력)이 됩니다.

<br>즉, 다음과 같은 식입니다.

0번 인덱스의 Monster의  이름이 Zombie, 체력이 100, 공격력이 40

0번 인덱스의 User의 이름이 Alex, 체력이 120, 공격력이 30 이라고 합시다.

[1턴]

Monster[0]의 체력 = 100(Monster[0]의 체력) - 30(User[0]의 공격력) = 70

User[0]의 체력 = 120(User[0]의 체력) - 40(Monster[0]의 공격력) = 80

[2턴]

Monster[0]의 체력 = 70(Monster[0]의 남은 체력) - 30(User[0]의 공격력) = 40

User[0]의 체력 = 80(User[0]의 남은 체력) - 40(Monster[0]의 공격력) = 40

[3턴]

Monster[0]의 체력 = 40(Monster[0]의 남은 체력) - 30(User[0]의 공격력) = 10

User[0]의 체력 = 40(User[0]의 남은 체력) - 40(Monster[0]의 공격력) = 0

…과 같은 식으로 **한 명의 체력이 0 이하**가 될 때까지 턴을 반복합니다.

4. 어떤 유닛의 체력이 0 이하로 떨어지게 되면, “{해당 유닛의 이름}이(가) 쓰러졌습니다!”를 출력하고, **쓰러진 유닛의 팀의 다음 인덱스의 유닛**이 상대 팀의 유닛과 마저 싸우기를 반복합니다.

위의 예시에서 3턴에 User[0]의 체력이 0이 되었으므로,

“Alex이(가) 쓰러졌습니다!”를 출력합니다.

**이후 새로운 User[1]이 아직 체력이 0보다 높은 Monster[0]과 마저 싸우게 됩니다.**

1번 인덱스의 Monster의 이름이 Skeleton, 체력이 80, 공격력이 30

1번 인덱스의 User의 이름이 James, 체력이 200, 공격력이 40 이라고 합시다.

그러면 아래와 같이 게임이 전개됩니다.

[1턴]

Monster[0]의 체력 = 10(Monster[0]의 남은 체력) - 40(User[1]의 공격력) = -30

User[1]의 체력 = 200(User[1]의 남은 체력) - 40(Monster[0]의 공격력) = 160

“Zombie이(가) 쓰러졌습니다!”를 출력, 새로운 턴 시작

[2턴]

Monster[1]의 체력 = 80(Monster[1]의 남은 체력) - 40(User[1]의 공격력) = 40

User[1]의 체력 = 160(User[1]의 남은 체력) - 40(Monster[1]의 공격력) = 120

[3턴]

Monster[1]의 체력 = 40(Monster[1]의 남은 체력) - 40(User[1]의 공격력) = 0

User[1]의 체력 = 120(User[1]의 남은 체력) - 40(Monster[1]의 공격력) = 80

“Skeleton이(가) 쓰러졌습니다!”를 출력, 새로운 턴 시작

…과 같은 식으로 **어떤 한 팀이 전멸**할 때까지 반복합니다.

5. 최종적으로 유닛이 한 마리(명) 이상 남아있는 팀이 승리합니다. Monster 팀이 이긴 경우 “몬스터 팀이 승리했습니다!”를, User 팀이 이긴 경우 “유저 팀이 승리했습니다!”를 출력합니다. 비긴 경우 “비겼습니다!”를 출력합니다.

[예제 시나리오1]

![5.jpg](5~6%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%20c29615bd86e1416bb3d653378e21d8e9/5.jpg)

[예제 시나리오2]

![6.jpg](5~6%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%20c29615bd86e1416bb3d653378e21d8e9/6.jpg)

[예제 시나리오 3]

![7.jpg](5~6%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6%20c29615bd86e1416bb3d653378e21d8e9/7.jpg)